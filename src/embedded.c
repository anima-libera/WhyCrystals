
/* This file is overwritten at each compilation.
 * Do not modify, see "embedded.h" or "_comp.py" instead. */

/* Content of "shaders/visuals.vert". */
const char g_shader_visuals_vert[] = "\n#version 430 core\nlayout(location = 0) in vec3 in_pos;\nlayout(location = 1) in vec2 in_wh;\nlayout(location = 2) in uvec4 in_texture_rect;\nlayout(location = 3) in vec2 in_texture_rect_origin;\nlayout(location = 4) in uint in_flags;\nout vec2 v_wh;\nout uvec4 v_texture_rect;\nout vec2 v_texture_rect_origin;\nout uint v_flags;\n\nvoid main()\n{\n\tgl_Position = vec4(in_pos, 1.0);\n\tv_wh = in_wh;\n\tv_texture_rect = in_texture_rect;\n\tv_texture_rect_origin = in_texture_rect_origin;\n\tv_flags = in_flags;\n}\n";

/* Content of "shaders/visuals.geom". */
const char g_shader_visuals_geom[] = "\n#version 430 core\nlayout(location = 1) uniform uvec2 u_window_wh;\nlayout(points) in;\nlayout(triangle_strip, max_vertices = 4) out;\nin vec2 v_wh[];\nin uvec4 v_texture_rect[];\nin vec2 v_texture_rect_origin[];\nin uint v_flags[];\nout vec2 g_texture_pos;\n\n#define VISUAL_USED 0x1\n#define VISUAL_VERTICAL 0x2\n\nvoid main()\n{\n\tvec2 texture_rect_topleft_xy = v_texture_rect[0].xy;\n\tfloat texture_rect_w = v_texture_rect[0].z;\n\tfloat texture_rect_h = v_texture_rect[0].w;\n\tvec2 texture_rect_origin_xy = v_texture_rect_origin[0];\n\tfloat texture_side = 256.0;\n\n\tvec3 pos_xyz = gl_in[0].gl_Position.xyz;\n\tfloat w = v_wh[0].x;\n\tfloat h = v_wh[0].y;\n\n\tfloat left_offset = -texture_rect_origin_xy.x * w;\n\tfloat right_offset = (1.0 - texture_rect_origin_xy.x) * w;\n\tfloat top_offset = (1.0 - texture_rect_origin_xy.y) * h;\n\tfloat bottom_offset = -texture_rect_origin_xy.y * h;\n\n\tbool used = (v_flags[0] & VISUAL_USED) != 0;\n\tbool vertical = (v_flags[0] & VISUAL_VERTICAL) != 0;\n\n\tfloat zoom_factor = 120.0;\n\tfloat depth_factor = 0.05;\n\n\tif (!used)\n\t{\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tEndPrimitive();\n\t\treturn;\n\t}\n\n\tg_texture_pos = texture_rect_topleft_xy;\n\tg_texture_pos += vec2(texture_rect_w * 0.0, texture_rect_h * 0.0);\n\tg_texture_pos /= texture_side;\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += left_offset;\n\tgl_Position.y += top_offset;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tif (vertical)\n\t{\n\t\tgl_Position.z -= h * depth_factor * 1.5;\n\t}\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tg_texture_pos = texture_rect_topleft_xy;\n\tg_texture_pos += vec2(texture_rect_w * 1.0, texture_rect_h * 0.0);\n\tg_texture_pos /= texture_side;\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += right_offset;\n\tgl_Position.y += top_offset;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tif (vertical)\n\t{\n\t\tgl_Position.z -= h * depth_factor * 1.5;\n\t}\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tg_texture_pos = texture_rect_topleft_xy;\n\tg_texture_pos += vec2(texture_rect_w * 0.0, texture_rect_h * 1.0);\n\tg_texture_pos /= texture_side;\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += left_offset;\n\tgl_Position.y += bottom_offset;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tg_texture_pos = texture_rect_topleft_xy;\n\tg_texture_pos += vec2(texture_rect_w * 1.0, texture_rect_h * 1.0);\n\tg_texture_pos /= texture_side;\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += right_offset;\n\tgl_Position.y += bottom_offset;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tEndPrimitive();\n}\n";

/* Content of "shaders/visuals.frag". */
const char g_shader_visuals_frag[] = "\n#version 430 core\nlayout(location = 0) uniform sampler2D u_tileset_texture;\nin vec2 g_texture_pos;\nout vec4 out_color;\n\nvoid main()\n{\n\tout_color = vec4(texture(u_tileset_texture, g_texture_pos));\n\tif (out_color.a < 0.001)\n\t{\n\t\tdiscard;\n\t}\n}\n";

/* Content of "shaders/pos.vert". */
const char g_shader_pos_vert[] = "\n#version 430 core\nlayout(location = 0) in uint in_flags;\nlayout(location = 1) in vec3 in_pos;\nout uint v_flags;\n\nvoid main()\n{\n\tgl_Position = vec4(in_pos, 1.0);\n\tv_flags = in_flags;\n}\n";

/* Content of "shaders/pos.geom". */
const char g_shader_pos_geom[] = "\n#version 430 core\nlayout(location = 1) uniform uvec2 u_window_wh;\nlayout(points) in;\nlayout(line_strip, max_vertices = 5) out;\nin uint v_flags[];\n\n#define OBJ_FLAG_EXISTS (1 << 0)\n\nvoid main()\n{\n\tbool exists = (v_flags[0] & OBJ_FLAG_EXISTS) != 0;\n\n\tif (!exists)\n\t{\n\t\t/* Discard the geometry. */\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tEndPrimitive();\n\t\treturn;\n\t}\n\n\tvec3 pos_xyz = gl_in[0].gl_Position.xyz;\n\tfloat zoom_factor = 120.0;\n\tfloat depth_factor = 0.05;\n\n\t/*   @   *\n\t * . . . *\n\t *   .   */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += 0.0;\n\tgl_Position.y += +0.5;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/*   .   *\n\t * . . . *\n\t *   @   */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += 0.0;\n\tgl_Position.y += -0.5;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/*   .   *\n\t * . @ . *\n\t *   .   */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += 0.0;\n\tgl_Position.y += 0.0;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/*   .   *\n\t * @ . . *\n\t *   .   */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += -0.5;\n\tgl_Position.y += 0.0;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/*   .   *\n\t * . . @ *\n\t *   .   */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += +0.5;\n\tgl_Position.y += 0.0;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tEndPrimitive();\n}\n";

/* Content of "shaders/pos.frag". */
const char g_shader_pos_frag[] = "\n#version 430 core\nout vec4 out_color;\n\nvoid main()\n{\n\tout_color = vec4(1.0, 1.0, 1.0, 1.0);\n}\n";

/* Content of "shaders/sprites.vert". */
const char g_shader_sprites_vert[] = "\n#version 430 core\nlayout(location = 0) in uint in_flags;\nlayout(location = 1) in vec3 in_pos;\nlayout(location = 2) in uint in_sprite_id;\nlayout(location = 3) in float in_scale;\nout uint v_flags;\nout uint v_sprite_id;\nout float v_scale;\n\nvoid main()\n{\n\tgl_Position = vec4(in_pos, 1.0);\n\tv_flags = in_flags;\n\tv_sprite_id = in_sprite_id;\n\tv_scale = in_scale;\n}\n";

/* Content of "shaders/sprites.geom". */
const char g_shader_sprites_geom[] = "\n#version 430 core\nlayout(location = 1) uniform uvec2 u_window_wh;\nlayout(points) in;\nlayout(triangle_strip, max_vertices = 4) out;\nstruct sprite_rect_t\n{\n\tuint x, y, w, h;\n\tfloat origin_x, origin_y;\n\tuint flags;\n\t#define SR_FLAG_VERTICAL (1 << 0)\n};\nlayout(shared, binding = 0) buffer sprite_rects\n{\n\tsprite_rect_t sprite_rect_array[];\n};\nin uint v_flags[];\n#define OBJ_FLAG_EXISTS (1 << 0)\nin uint v_sprite_id[];\nin float v_scale[];\nout vec2 g_atlas_pos;\n\n#define ATLAS_SIDE 1024\n\nvoid main()\n{\n\tbool exists = (v_flags[0] & OBJ_FLAG_EXISTS) != 0;\n\n\tif (!exists)\n\t{\n\t\t/* Discard the geometry. */\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tEndPrimitive();\n\t\treturn;\n\t}\n\n\tsprite_rect_t sr = sprite_rect_array[v_sprite_id[0]];\n\tvec2 sr_xy = vec2(float(sr.x), float(sr.y)) / float(ATLAS_SIDE);\n\tvec2 sr_wh = vec2(float(sr.w), float(sr.h)) / float(ATLAS_SIDE);\n\tvec2 sr_origin = vec2(sr.origin_x, sr.origin_y);\n\tbool vertical = (sr.flags & SR_FLAG_VERTICAL) != 0;\n\n\tvec3 pos_xyz = gl_in[0].gl_Position.xyz;\n\tvec2 wh = vec2(float(sr.w), float(sr.h));\n\tfloat scale = v_scale[0] * 0.1;\n\n\tfloat zoom_factor = 120.0;\n\tfloat depth_factor = 0.05;\n\n\t/* @ . *\n\t * . . */\n\tg_atlas_pos = sr_xy + vec2(sr_wh.x * 0, sr_wh.y * 1);\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.xy +=\n\t\tvec2((0.0-sr_origin.x) * wh.x, (0.0-sr_origin.y) * wh.y) * scale;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tif (vertical)\n\t{\n\t\tgl_Position.z += (1.0-sr_origin.y) * wh.y * scale * depth_factor * 1.5;\n\t}\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/* . @ *\n\t * . . */\n\tg_atlas_pos = sr_xy + vec2(sr_wh.x * 1, sr_wh.y * 1);\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.xy +=\n\t\tvec2((1.0-sr_origin.x) * wh.x, (0.0-sr_origin.y) * wh.y) * scale;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tif (vertical)\n\t{\n\t\tgl_Position.z += (1.0-sr_origin.y) * wh.y * scale * depth_factor * 1.5;\n\t}\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/* . . *\n\t * @ . */\n\tg_atlas_pos = sr_xy + vec2(sr_wh.x * 0, sr_wh.y * 0);\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.xy +=\n\t\tvec2((0.0-sr_origin.x) * wh.x, (1.0-sr_origin.y) * wh.y) * scale;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/* . . *\n\t * . @ */\n\tg_atlas_pos = sr_xy + vec2(sr_wh.x * 1, sr_wh.y * 0);\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.xy +=\n\t\tvec2((1.0-sr_origin.x) * wh.x, (1.0-sr_origin.y) * wh.y) * scale;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tEndPrimitive();\n}\n";

/* Content of "shaders/sprites.frag". */
const char g_shader_sprites_frag[] = "\n#version 430 core\nlayout(location = 0) uniform sampler2D u_atlas;\nin vec2 g_atlas_pos;\nout vec4 out_color;\n\nvoid main()\n{\n\tout_color = vec4(texture(u_atlas, g_atlas_pos));\n\tif (out_color.a < 0.001)\n\t{\n\t\tdiscard;\n\t}\n}\n";
