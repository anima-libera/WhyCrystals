
/* This file is overwritten at each compilation.
 * Do not modify, see "embedded.h" or "_comp.py" instead. */

/* Content of "shaders/pos.vert". */
const char g_shader_pos_vert[] = "\n#version 430 core\nlayout(location = 0) in uint in_flags;\nlayout(location = 1) in vec3 in_pos;\nout uint v_flags;\n\nvoid main()\n{\n\tgl_Position = vec4(in_pos, 1.0);\n\tv_flags = in_flags;\n}\n";

/* Content of "shaders/pos.geom". */
const char g_shader_pos_geom[] = "\n#version 430 core\nlayout(location = 1) uniform uvec2 u_window_wh;\nlayout(points) in;\nlayout(line_strip, max_vertices = 5) out;\nin uint v_flags[];\n#define OBJ_FLAG_EXISTS (1 << 0)\n\nvoid main()\n{\n\tbool exists = (v_flags[0] & OBJ_FLAG_EXISTS) != 0;\n\n\tif (!exists)\n\t{\n\t\t/* Discard the geometry. */\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tEndPrimitive();\n\t\treturn;\n\t}\n\n\tvec3 pos_xyz = gl_in[0].gl_Position.xyz;\n\tfloat zoom_factor = 120.0;\n\tfloat depth_factor = 0.05;\n\n\t/*   @   *\n\t * . . . *\n\t *   .   */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += 0.0;\n\tgl_Position.y += +0.5;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/*   .   *\n\t * . . . *\n\t *   @   */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += 0.0;\n\tgl_Position.y += -0.5;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/*   .   *\n\t * . @ . *\n\t *   .   */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += 0.0;\n\tgl_Position.y += 0.0;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/*   .   *\n\t * @ . . *\n\t *   .   */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += -0.5;\n\tgl_Position.y += 0.0;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/*   .   *\n\t * . . @ *\n\t *   .   */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += +0.5;\n\tgl_Position.y += 0.0;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tEndPrimitive();\n}\n";

/* Content of "shaders/pos.frag". */
const char g_shader_pos_frag[] = "\n#version 430 core\nout vec4 out_color;\n\nvoid main()\n{\n\tout_color = vec4(1.0, 1.0, 1.0, 1.0);\n}\n";

/* Content of "shaders/sprite_rect.vert". */
const char g_shader_sprite_rect_vert[] = "\n#version 430 core\nlayout(location = 0) in uint in_flags;\nlayout(location = 1) in vec3 in_pos;\nlayout(location = 2) in uint in_sprite_id;\nlayout(location = 3) in float in_scale;\nout uint v_flags;\nout uint v_sprite_id;\nout float v_scale;\n\nvoid main()\n{\n\tgl_Position = vec4(in_pos, 1.0);\n\tv_flags = in_flags;\n\tv_sprite_id = in_sprite_id;\n\tv_scale = in_scale;\n}\n";

/* Content of "shaders/sprite_rect.geom". */
const char g_shader_sprite_rect_geom[] = "\n#version 430 core\nlayout(location = 1) uniform uvec2 u_window_wh;\nlayout(points) in;\nlayout(line_strip, max_vertices = 5) out;\nstruct sprite_rect_t\n{\n\tuint x, y, w, h;\n\tfloat origin_x, origin_y;\n\tuint flags;\n\t#define SR_FLAG_VERTICAL (1 << 0)\n};\nlayout(shared, binding = 0) buffer sprite_rects\n{\n\tsprite_rect_t sprite_rect_array[];\n};\nin uint v_flags[];\n#define OBJ_FLAG_EXISTS (1 << 0)\nin uint v_sprite_id[];\nin float v_scale[];\n\n#define ATLAS_SIDE 1024\n\nvoid main()\n{\n\tbool exists = (v_flags[0] & OBJ_FLAG_EXISTS) != 0;\n\n\tif (!exists)\n\t{\n\t\t/* Discard the geometry. */\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tEndPrimitive();\n\t\treturn;\n\t}\n\n\tsprite_rect_t sr = sprite_rect_array[v_sprite_id[0]];\n\tvec2 sr_xy = vec2(float(sr.x), float(sr.y)) / float(ATLAS_SIDE);\n\tvec2 sr_wh = vec2(float(sr.w), float(sr.h)) / float(ATLAS_SIDE);\n\tvec2 sr_origin = vec2(sr.origin_x, sr.origin_y);\n\tbool vertical = (sr.flags & SR_FLAG_VERTICAL) != 0;\n\n\tfloat zoom_factor = 120.0;\n\tfloat depth_factor = 0.05;\n\tfloat scale_factor = 0.1;\n\n\tvec3 pos_xyz = gl_in[0].gl_Position.xyz;\n\tvec2 wh = vec2(float(sr.w), float(sr.h));\n\tfloat scale = v_scale[0] * scale_factor;\n\n\tfloat sr_margin = 0.1 / float(ATLAS_SIDE);\n\n\t/* . . *\n\t * @ . */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.xy +=\n\t\tvec2((0.0-sr_origin.x) * wh.x, (0.0-sr_origin.y) * wh.y) * scale;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/* . . *\n\t * . @ */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.xy +=\n\t\tvec2((1.0-sr_origin.x) * wh.x, (0.0-sr_origin.y) * wh.y) * scale;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/* . @ *\n\t * . . */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.xy +=\n\t\tvec2((1.0-sr_origin.x) * wh.x, (1.0-sr_origin.y) * wh.y) * scale;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/* @ . *\n\t * . . */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.xy +=\n\t\tvec2((0.0-sr_origin.x) * wh.x, (1.0-sr_origin.y) * wh.y) * scale;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/* . . *\n\t * @ . */\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.xy +=\n\t\tvec2((0.0-sr_origin.x) * wh.x, (0.0-sr_origin.y) * wh.y) * scale;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tEndPrimitive();\n}\n";

/* Content of "shaders/sprite_rect.frag". */
const char g_shader_sprite_rect_frag[] = "\n#version 430 core\nout vec4 out_color;\n\nvoid main()\n{\n\tout_color = vec4(1.0, 0.0, 0.0, 1.0);\n}\n";

/* Content of "shaders/sprite.vert". */
const char g_shader_sprite_vert[] = "\n#version 430 core\nlayout(location = 0) in uint in_flags;\nlayout(location = 1) in vec3 in_pos;\nlayout(location = 2) in uint in_sprite_id;\nlayout(location = 3) in float in_scale;\nout uint v_flags;\nout uint v_sprite_id;\nout float v_scale;\n\nvoid main()\n{\n\tgl_Position = vec4(in_pos, 1.0);\n\tv_flags = in_flags;\n\tv_sprite_id = in_sprite_id;\n\tv_scale = in_scale;\n}\n";

/* Content of "shaders/sprite.geom". */
const char g_shader_sprite_geom[] = "\n#version 430 core\nlayout(location = 1) uniform uvec2 u_window_wh;\nlayout(points) in;\nlayout(triangle_strip, max_vertices = 4) out;\nstruct sprite_rect_t\n{\n\tuint x, y, w, h;\n\tfloat origin_x, origin_y;\n\tuint flags;\n\t#define SR_FLAG_VERTICAL (1 << 0)\n};\nlayout(shared, binding = 0) buffer sprite_rects\n{\n\tsprite_rect_t sprite_rect_array[];\n};\nin uint v_flags[];\n#define OBJ_FLAG_EXISTS (1 << 0)\nin uint v_sprite_id[];\nin float v_scale[];\nout vec2 g_atlas_pos;\n\n#define ATLAS_SIDE 1024\n\nvoid main()\n{\n\tbool exists = (v_flags[0] & OBJ_FLAG_EXISTS) != 0;\n\n\tif (!exists)\n\t{\n\t\t/* Discard the geometry. */\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tEndPrimitive();\n\t\treturn;\n\t}\n\n\tsprite_rect_t sr = sprite_rect_array[v_sprite_id[0]];\n\tvec2 sr_xy = vec2(float(sr.x), float(sr.y)) / float(ATLAS_SIDE);\n\tvec2 sr_wh = vec2(float(sr.w), float(sr.h)) / float(ATLAS_SIDE);\n\tvec2 sr_origin = vec2(sr.origin_x, sr.origin_y);\n\tbool vertical = (sr.flags & SR_FLAG_VERTICAL) != 0;\n\n\tfloat zoom_factor = 120.0;\n\tfloat depth_factor = 0.05;\n\tfloat scale_factor = 0.1;\n\n\tvec3 pos_xyz = gl_in[0].gl_Position.xyz;\n\tvec2 wh = vec2(float(sr.w), float(sr.h));\n\tfloat scale = v_scale[0] * scale_factor;\n\n\tfloat sr_margin = 0.1 / float(ATLAS_SIDE);\n\n\t/* . . *\n\t * @ . */\n\tg_atlas_pos = sr_xy + vec2(sr_wh.x * 0, sr_wh.y * 1);\n\tg_atlas_pos += vec2(+1, -1) * sr_margin;\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.xy +=\n\t\tvec2((0.0-sr_origin.x) * wh.x, (0.0-sr_origin.y) * wh.y) * scale;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/* . . *\n\t * . @ */\n\tg_atlas_pos = sr_xy + vec2(sr_wh.x * 1, sr_wh.y * 1);\n\tg_atlas_pos += vec2(-1, -1) * sr_margin;\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.xy +=\n\t\tvec2((1.0-sr_origin.x) * wh.x, (0.0-sr_origin.y) * wh.y) * scale;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/* @ . *\n\t * . . */\n\tg_atlas_pos = sr_xy + vec2(sr_wh.x * 0, sr_wh.y * 0);\n\tg_atlas_pos += vec2(+1, +1) * sr_margin;\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.xy +=\n\t\tvec2((0.0-sr_origin.x) * wh.x, (1.0-sr_origin.y) * wh.y) * scale;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tif (vertical)\n\t{\n\t\tgl_Position.z -= (1.0-sr_origin.y) * wh.y * scale * depth_factor * 1.5;\n\t}\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\t/* . @ *\n\t * . . */\n\tg_atlas_pos = sr_xy + vec2(sr_wh.x * 1, sr_wh.y * 0);\n\tg_atlas_pos += vec2(-1, +1) * sr_margin;\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.xy +=\n\t\tvec2((1.0-sr_origin.x) * wh.x, (1.0-sr_origin.y) * wh.y) * scale;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tif (vertical)\n\t{\n\t\tgl_Position.z -= (1.0-sr_origin.y) * wh.y * scale * depth_factor * 1.5;\n\t}\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tEndPrimitive();\n}\n";

/* Content of "shaders/sprite.frag". */
const char g_shader_sprite_frag[] = "\n#version 430 core\nlayout(location = 0) uniform sampler2D u_atlas;\nin vec2 g_atlas_pos;\nout vec4 out_color;\n\nvoid main()\n{\n\tout_color = vec4(texture(u_atlas, g_atlas_pos));\n\tif (out_color.a < 0.001)\n\t{\n\t\tdiscard;\n\t}\n}\n";
