
/* This file is overwritten at each compilation.
 * Do not modify, see "embedded.h" or "_comp.py" instead. */

/* Content of "shaders/visuals.vert". */
const char g_shader_visuals_vert[] = "\n#version 430 core\nlayout(location = 0) in vec3 in_pos;\nlayout(location = 1) in vec2 in_wh;\nlayout(location = 2) in uvec4 in_texture_rect;\nlayout(location = 3) in vec2 in_texture_rect_origin;\nlayout(location = 4) in uint in_flags;\nout vec2 v_wh;\nout uvec4 v_texture_rect;\nout vec2 v_texture_rect_origin;\nout uint v_flags;\n\nvoid main()\n{\n\tgl_Position = vec4(in_pos, 1.0);\n\tv_wh = in_wh;\n\tv_texture_rect = in_texture_rect;\n\tv_texture_rect_origin = in_texture_rect_origin;\n\tv_flags = in_flags;\n}\n";

/* Content of "shaders/visuals.geom". */
const char g_shader_visuals_geom[] = "\n#version 430 core\nlayout(location = 1) uniform uvec2 u_window_wh;\nlayout(points) in;\nlayout(triangle_strip, max_vertices = 4) out;\nin vec2 v_wh[];\nin uvec4 v_texture_rect[];\nin vec2 v_texture_rect_origin[];\nin uint v_flags[];\nout vec2 g_texture_pos;\n\n#define VISUAL_USED 0x1\n#define VISUAL_VERTICAL 0x2\n\nvoid main()\n{\n\tvec2 texture_rect_topleft_xy = v_texture_rect[0].xy;\n\tfloat texture_rect_w = v_texture_rect[0].z;\n\tfloat texture_rect_h = v_texture_rect[0].w;\n\tvec2 texture_rect_origin_xy = v_texture_rect_origin[0];\n\tfloat texture_side = 256.0;\n\n\tvec3 pos_xyz = gl_in[0].gl_Position.xyz;\n\tfloat w = v_wh[0].x;\n\tfloat h = v_wh[0].y;\n\n\tfloat left_offset = -texture_rect_origin_xy.x * w;\n\tfloat right_offset = (1.0 - texture_rect_origin_xy.x) * w;\n\tfloat top_offset = (1.0 - texture_rect_origin_xy.y) * h;\n\tfloat bottom_offset = -texture_rect_origin_xy.y * h;\n\n\tbool used = (v_flags[0] & VISUAL_USED) != 0;\n\tbool vertical = (v_flags[0] & VISUAL_VERTICAL) != 0;\n\n\tfloat zoom_factor = 120.0;\n\tfloat depth_factor = 0.05;\n\n\tif (!used)\n\t{\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tEndPrimitive();\n\t\treturn;\n\t}\n\n\tg_texture_pos = texture_rect_topleft_xy;\n\tg_texture_pos += vec2(texture_rect_w * 0.0, texture_rect_h * 0.0);\n\tg_texture_pos /= texture_side;\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += left_offset;\n\tgl_Position.y += top_offset;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tif (vertical)\n\t{\n\t\tgl_Position.z -= h * depth_factor * 1.5;\n\t}\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tg_texture_pos = texture_rect_topleft_xy;\n\tg_texture_pos += vec2(texture_rect_w * 1.0, texture_rect_h * 0.0);\n\tg_texture_pos /= texture_side;\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += right_offset;\n\tgl_Position.y += top_offset;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tif (vertical)\n\t{\n\t\tgl_Position.z -= h * depth_factor * 1.5;\n\t}\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tg_texture_pos = texture_rect_topleft_xy;\n\tg_texture_pos += vec2(texture_rect_w * 0.0, texture_rect_h * 1.0);\n\tg_texture_pos /= texture_side;\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += left_offset;\n\tgl_Position.y += bottom_offset;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tg_texture_pos = texture_rect_topleft_xy;\n\tg_texture_pos += vec2(texture_rect_w * 1.0, texture_rect_h * 1.0);\n\tg_texture_pos /= texture_side;\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += right_offset;\n\tgl_Position.y += bottom_offset;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tEndPrimitive();\n}\n";

/* Content of "shaders/visuals.frag". */
const char g_shader_visuals_frag[] = "\n#version 430 core\nlayout(location = 0) uniform sampler2D u_tileset_texture;\nin vec2 g_texture_pos;\nout vec4 out_color;\n\nvoid main()\n{\n\tout_color = vec4(texture(u_tileset_texture, g_texture_pos));\n\tif (out_color.a < 0.01)\n\t{\n\t\tdiscard;\n\t}\n}\n";

/* Content of "shaders/pos.vert". */
const char g_shader_pos_vert[] = "\n#version 430 core\nlayout(location = 0) in uint in_flags;\nlayout(location = 1) in vec3 in_pos;\nout uint v_flags;\n\nvoid main()\n{\n\tgl_Position = vec4(in_pos, 1.0);\n\tv_flags = in_flags;\n}\n";

/* Content of "shaders/pos.geom". */
const char g_shader_pos_geom[] = "\n#version 430 core\nlayout(location = 1) uniform uvec2 u_window_wh;\nlayout(points) in;\nlayout(line_strip, max_vertices = 5) out;\nin uint v_flags[];\n\n#define OBJ_FLAG_EXISTS (1 << 0)\n\nvoid main()\n{\n\tbool exists = (v_flags[0] & OBJ_FLAG_EXISTS) != 0;\n\n\tif (!exists)\n\t{\n\t\t/* Discard the geometry. */\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tEndPrimitive();\n\t\treturn;\n\t}\n\n\tvec3 pos_xyz = gl_in[0].gl_Position.xyz;\n\tfloat zoom_factor = 120.0;\n\tfloat depth_factor = 0.05;\n\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += 0.0;\n\tgl_Position.y += +0.5;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += 0.0;\n\tgl_Position.y += -0.5;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += 0.0;\n\tgl_Position.y += 0.0;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += -0.5;\n\tgl_Position.y += 0.0;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += +0.5;\n\tgl_Position.y += 0.0;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = -1.0;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tEndPrimitive();\n}\n";

/* Content of "shaders/pos.frag". */
const char g_shader_pos_frag[] = "\n#version 430 core\nout vec4 out_color;\n\nvoid main()\n{\n\tout_color = vec4(1.0, 1.0, 1.0, 1.0);\n}\n";

/* Content of "shaders/sprites.vert". */
const char g_shader_sprites_vert[] = "\n#version 430 core\nlayout(location = 0) in uint in_flags;\nlayout(location = 1) in vec3 in_pos;\nlayout(location = 2) in uint in_sprite_id;\nout uint v_flags;\nout uint v_sprite_id;\n\nvoid main()\n{\n\tgl_Position = vec4(in_pos, 1.0);\n\tv_flags = in_flags;\n\tv_sprite_id = in_sprite_id;\n}\n";

/* Content of "shaders/sprites.geom". */
const char g_shader_sprites_geom[] = "\n#version 430 core\nlayout(location = 1) uniform uvec2 u_window_wh;\nlayout(points) in;\nlayout(triangle_strip, max_vertices = 4) out;\nin uint v_flags[];\nin uint v_sprite_id[];\nout vec2 g_atlas_pos;\n\n#define OBJ_FLAG_EXISTS (1 << 0)\n\nvoid main()\n{\n\tbool exists = (v_flags[0] & OBJ_FLAG_EXISTS) != 0;\n\n\tif (!exists)\n\t{\n\t\t/* Discard the geometry. */\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tgl_Position = vec4(-2, -2, -2, 1);\n\t\tEmitVertex();\n\t\tEndPrimitive();\n\t\treturn;\n\t}\n\n\tvec3 pos_xyz = gl_in[0].gl_Position.xyz;\n\tfloat zoom_factor = 120.0;\n\tfloat depth_factor = 0.05;\n\n\tg_atlas_pos = vec2(0, 0);\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += -0.5;\n\tgl_Position.y += +0.5;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tg_atlas_pos = vec2(1, 0);\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += +0.5;\n\tgl_Position.y += +0.5;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tg_atlas_pos = vec2(0, 1);\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += -0.5;\n\tgl_Position.y += -0.5;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tg_atlas_pos = vec2(1, 1);\n\tgl_Position = vec4(pos_xyz.xy, 0, 1);\n\tgl_Position.x += +0.5;\n\tgl_Position.y += -0.5;\n\tgl_Position.y += pos_xyz.z;\n\tgl_Position.z = gl_Position.y * depth_factor;\n\tgl_Position.x *= zoom_factor / u_window_wh.x;\n\tgl_Position.y *= zoom_factor / u_window_wh.y;\n\tEmitVertex();\n\n\tEndPrimitive();\n}\n";

/* Content of "shaders/sprites.frag". */
const char g_shader_sprites_frag[] = "\n#version 430 core\nlayout(location = 0) uniform sampler2D u_atlas;\nin vec2 g_atlas_pos;\nout vec4 out_color;\n\nvoid main()\n{\n\tout_color = vec4(texture(u_atlas, g_atlas_pos));\n\tif (out_color.a < 0.01)\n\t{\n\t\tdiscard;\n\t}\n}\n";
